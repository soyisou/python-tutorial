# author : LJM - Jeson
# Email  : 878665865@qq.com
# coding : utf - 8
'''
魔术方法就是一个类的特殊方法，和普通方法唯一的不同是：普通方法需要调用，而魔术方法有系统自动调用！
    。__init__()
        。初始化魔术方法
        。触发时机：初始化对象时触发(不是实例化触发，但是和实例化在一个操作中)
        。p1 = Person()
        。p1对象  实例化对象p1  p1实例
        。参数：至少有一个self，接收对象
        。返回值：无
        。作用：初始化对象成员
    。__new__()
        。实例化魔术方法 类方法
        。触发时机：在实例化对象时触发
        。参数：至少一个 cls 接收当前类
        。返回值：必须返回一个对象实例
        。作用：实例化对象
        。注意：实例化对象是object类底层实现，其他类继承了object的__new__才能够实例化对象。
        。没事别碰这个魔术方法，先触发__new__才会触发__init__
    。__del__
        。析构魔术方法
        。触发时机：当对象没有用（没有任何变量引用）的时候触发
        。参数：一个self
        。返回值：无
        。作用：在销毁对象是回收资源
        。注意：del不一定会触发当前方法，只有当前对象没有任何变量引用时才会触发
    。
'''

class Person:  # 默认继承object ---- class Person(object)
    def __init__(self):
        print('----> init')

    # __new__不写，默认调用系统的
    # 类方法  为何没有加 @ ？ 底层已经帮我们处理好了，我们就不用管了
    def __new__(cls, *args, **kwargs):  # 五个步骤，__new__就是帮你开辟空间的，将开辟的空间扔给__init__的self
        print('----> new')  # 自己写的这个__new__, 此时可没有创建空间！
        return object.__new__(cls)  # 此时便创建了空间

    # 不建议大家重写
    def __del__(self):
        print('----> del')

p = Person()
print(p)
"""
----> new
----> init
<__main__.Person object at 0x0000022D8F610F48>
"""
p3 = p  # 当有多个引用，断开一个引用，不会触发__del__，只有没有任何引用的时候，才会回收，才会触发__del__
del p  # 系统关键字，del 作用：断开p 与对象之间的引用关系

print('=' * 50)

p1 = Person()
print(p1)

print('=' * 50)

p2 = Person()
print(p2)
print('---------over--------')