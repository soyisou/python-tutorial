# author : LJM - Jeson
# Email  : 878665865@qq.com
# coding : utf - 8
'''
单例(singleton)
单例是一种设计模式[设计模型]，应用该模式的类只会生成一个实例。
单例模式保证了在程序的不同位置都可以且仅可以取到同一个对象实例：如果实例不存在，会创建一个实例，如果已经存在就会
返回这个实例。因为单例是一个类，所以你也可以为其提供相应的操作方法，以便于对这个实例进行管理。
举个例子来说，比如你开发一款游戏软件，游戏中需要有‘ 场景管理器’这样的一种东西，用来管理游戏场景的切换、资源载入、
网络连接等任务。这个管理器需要有多种方法和属性，在代码中很多地方都会被调用，且被调用的必须是同一个管理器，否则
既容易产生冲突，也会浪费资源。在这种情况下，单例模式就是一个很好的实现方法。广泛应用于各种游戏开发场景，对于开发
者而言是必须掌握的知识点，同时在很多的面试中，也是常见问题。
'''
# class Person:
#     def __init__(self):
#         print('----> init')
#
# # 打印了三遍：----> init
# p1 = Person()  # ----> init
# p2 = Person()  # ----> init
# p3 = Person()  # ----> init
#
# print(id(p1))  # 2273214867272
# print(id(p2))  # 2273214867336
# print(id(p3))  # 2273214868232

# 思考：如果自始至终，我仅仅想保留一个实例化对象，即一个地址，怎么办呢？
class Person:
    '''
    补充：
        。加一个_, 比如：_tpye
            。作用：避免起名冲突
        。加两个__, 比如：__instance
            。作用：表示私有化
    '''
    # 私有化
    __instance = None  # 第一遍为空，第二遍便不为空了，自始至终用的都是一个地址
    # 思考：谁是帮我们造地址的？  __new__
    def __new__(cls, *args, **kwargs):
        # 如果是空值，则创建一个地址
        if cls.__instance is None:
            cls.__instance = object.__new__(cls)
        return cls.__instance  # 将地址扔出去


    def __init__(self):
        print('----> init')

# 打印了三遍：----> init
p1 = Person()  # ----> init
p2 = Person()  # ----> init
p3 = Person()  # ----> init

# 都是同一个地址
print(id(p1))  # 2231253018312
print(id(p2))  # 2231253018312
print(id(p3))  # 2231253018312

