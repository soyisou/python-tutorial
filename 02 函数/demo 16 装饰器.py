# author : LJM - Jeson
# Email  : 878665865@qq.com
# coding : utf - 8
'''
装饰器(decorator)功能：
    。引入日志  ***
    。函数执行时间统计
    。执行函数前预备处理
    。执行函数后清理功能
    。权限校验等场景  ***
    。缓存  ***

装饰器：
    。装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这事也Python面试中必问的问题。
      这个都不会，别跟人家说你会Python，看了下面的文章，保证你学会装饰器。
    1. 先明白这段代码
    #### 第一波 ####
    def foo():
        print('foo')

    foo()  # 表示执行foo函数

    #### 第二波 ####
    def foo():
        print('foo')

    def foo1():
        print('foo1')

    foo = foo1

    foo()  # 打印的便是 foo1

    函数名仅仅一个变量，只不过指向了定义的函数而已，所以才能通过函数名()调用，如果函数名 = XXX 被修改了，
    那么当执行函数名()时，调用的就不是之前的那个函数了

    2. 需求来了
    初到公司有N个业务部门，基础平台部门负责提供底层的功能，如：数据库操作、redis调用，监控API等功能。业务部门
    使用基础功能时，只需要调用基础平台提供的功能即可。如下：
    ########## 基础平台提供的功能如下 ##########
    def show1():
        print('show1')

    def show2():
        print('show2')

    def show3():
        print('show3')

    ########## 业务部门：student 调用基础平台提供的功能 ##########
    show1()
    show2()
    show3()

     ########## 业务部门：teacher 调用基础平台提供的功能 ##########
    show1()
    show2()
    show3()

    目前公司有条不紊地进行着，但是，以前基础平台的开发人员在写代码时候没有关注验证相关的问题，即：基础平台的提供的功能
    可以被任何人使用，老大把工作交给小王，他是这么做的：
    跟每个业务部门交涉，每个业务部门自己写代码，调用基础平台的功能之前先验证。哎，这么一来，基础平台就不需要做任何修改了。
    太棒了，有充足的时间泡妹子了···
    当天，小王被开除了···
    老大把工作交给隔壁老王，他是这么做的：
    ########## 基础平台提供的功能如下 ##########
    def show1():
        # 验证1
        # 验证2
        # 验证3
        print('show1')

    def show2():
        # 验证1
        # 验证2
        # 验证3
        print('show2')

    def show3():
        # 验证1
        # 验证2
        # 验证3
        print('show3')

    过了一周，隔壁老王也被开除了···
    老大把工作交个隔壁小王，他是这么做的：
    只对基础平台的代码进行重构，其他业务部门无需做任何修改
    ########## 基础平台提供的功能如下 ##########
    def check_login()
        # 验证1
        # 验证2
        # 验证3
        pass

    def show1():
        check_login()
        print('show1')

    def show2():
        check_login()
        print('show2')

    def show3():
        check_login()
        print('show3')

    老大看了下隔壁小王的实现，嘴角漏出了一丝欣慰的笑，语重心长地跟隔壁小王聊了个天：
    老大说：
    写代码要遵循开放封闭原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，
    简单来说，它规定已经实现的功能代码不允许被修改，但是可以被扩展，即：
        。封闭：已实现的功能代码块
        。开放：对其进行扩展开发
    如果将开放封闭原则应用在上述需求中，那么就不允许在函数 show1, show2, show3的内部进行修改代码，老板就给了隔壁小王
    一个实现方案：
    def w1(func):
        def inner():
            # 验证1
            # 验证2
            # 验证3
            func()
        return inner

    @w1
    def show1():
        print('show1')

    @w1
    def show2():
        print('show2')

    @w1
    def show3():
        print('show3')

    对于上述代码，也是仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数show1, show2, show3 之前都进行[验证]
    操作，并且其他业务部门无需做任何操作。这段代码的内部执行原理是什么呢？详细讲解开始了···

    注：python装饰器(decorator)在实现的时候，被装饰后的函数其实已经是另外一个函数了(函数名等函数属性发生了改变)
'''
# 1. 定义装饰器函数， 该函数要遵循： 闭包原则 + 函数作为参数 (f)
def func(f):  # 装饰器函数
    print('------------>1')
    def wrapper(): # 装饰器，我们常叫包裹
        print('装饰前···验证是否登录')
        f()
        print('装饰后···')

    print('------------>2')
    return wrapper  # 千万不要加括号！

# 2. 定义功能函数
@func  # 格式：@ + 装饰器函数名   ---> 只要加该句，它已经偷偷地帮你调用装饰器函数, 具体过程：
# 1. 调用函数func 2. 执行函数中的内容 3.加载内部函数 4. 返回内部函数wrapper 5.buy_ticket接收了func的返回值，buy_ticket = wrapper
def buy_ticket():
    print('我可以买票去看：哪吒')

# 3. 买票
buy_ticket()
# print(buy_ticket)  # <function func.<locals>.wrapper at 0x0000017652A458B8>